use std::fmt::{Display, Formatter};

use crate::*;
use crate::file::{FilePath, FileManResult};

use chrono::Local;

pub type ConsoleResult<T> = Result<T, ()>;

pub trait ConsoleLogTranslator: Send {
    fn translate(&self, lang: &str) -> ConsoleLog;
}

#[derive(Clone, PartialEq)]
pub enum ConsoleLogKind {
    Error,
    Warning,
    Note,
}

impl ConsoleLogKind {
    pub fn from(v: String) -> Option<ConsoleLogKind> {
        let kind = match v.as_str() {
            "E" => ConsoleLogKind::Error,
            "W" => ConsoleLogKind::Warning,
            "N" => ConsoleLogKind::Note,
            _ => return None,
        };

        return Some(kind);
    }

    fn get_log_color_num(&self) -> usize {
        return match self {
            ConsoleLogKind::Error => 31,
            ConsoleLogKind::Warning => 33,
            ConsoleLogKind::Note => 34,
        };
    }

    fn get_log_kind_name(&self) -> String {
        let s = match self {
            ConsoleLogKind::Error => "err",
            ConsoleLogKind::Warning => "warn",
            ConsoleLogKind::Note => "note",
        };

        return s.to_string();
    }
}

pub struct ConsoleLog {
    pub kind: ConsoleLogKind,
    pub msg: String,
}

impl ConsoleLog {
    pub fn new(kind: ConsoleLogKind, msg: String) -> ConsoleLog {
        return ConsoleLog {
            kind: kind,
            msg: msg,
        }
    }
}

#[derive(Clone, PartialEq)]
pub enum LogFileKind {
    TextLines(Vec<String>),
    ConsoleLogs,
}

#[derive(Clone, PartialEq)]
pub struct LogFile {
    kind: LogFileKind,
    output_path: String,
}

impl LogFile {
    pub fn new(kind: LogFileKind, output_path: String) -> LogFile {
        return LogFile {
            kind: kind,
            output_path: output_path,
        };
    }
}

#[derive(Clone, Debug, PartialEq)]
pub enum ConsoleLogLimit {
    NoLimit,
    Limited(usize),
}

impl Display for ConsoleLogLimit {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            ConsoleLogLimit::NoLimit => "[nolimit]".to_string(),
            ConsoleLogLimit::Limited(limit_count) => limit_count.to_string(),
        };

        return write!(f, "{}", s);
    }
}

pub struct Console {
    lang: String,
    log_list: Vec<ConsoleLog>,
    log_limit: ConsoleLogLimit,
    pub ignore_logs: bool,
}

impl Console {
    pub fn new(lang: String, log_limit: ConsoleLogLimit) -> Console {
        return Console {
            lang: lang,
            log_list: Vec::new(),
            log_limit: log_limit,
            ignore_logs: false,
        };
    }

    pub fn get_lang(&self) -> &str {
        return &self.lang;
    }

    pub fn append_log(&mut self, log: ConsoleLog) {
        if !self.ignore_logs {
            self.log_list.push(log);
        }
    }

    pub fn clear(&mut self) {
        self.log_list.clear();
    }

    pub fn pop_log(&mut self) {
        if self.log_list.len() > 0 {
            self.log_list.pop();
        }
    }

    pub fn output(&self, log_files: Vec<LogFile>) {
        let mut cons_log_lines = Vec::<String>::new();
        self.print_all(&mut cons_log_lines);

        match self.write_all(log_files, cons_log_lines) {
            Ok(()) => (),
            Err(_) => println!("{}", Console::format_log_file_writing_failure_log()),
        };
    }

    fn write_all(&self, log_files: Vec<LogFile>, cons_log_lines: Vec<String>) -> FileManResult<()> {
        let header = vec![
            "--- Log File ---",
            "",
            &format!(" * created at {}", Local::now()),
            " * generated by cons-util",
        ].join("\n");

        for each_file_log in log_files {
            let lines = match &each_file_log.kind {
                LogFileKind::TextLines(lines) => lines,
                LogFileKind::ConsoleLogs => &cons_log_lines,
            };

            let output_content = header.clone() + "\n\n" + &lines.join("\n");

            // [fix] use write_lines()
            FilePath::write(&FilePath::new(each_file_log.output_path), &output_content)?;
        }

        return Ok(());
    }

    fn print_all(&self, log_lines: &mut Vec<String>) {
        // note: ログ数制限のチェック
        let limit_num = match &self.log_limit {
            ConsoleLogLimit::NoLimit => -1i32,
            ConsoleLogLimit::Limited(v) => *v as i32,
        };

        let mut log_count = 0;

        for each_log in &self.log_list {
            if limit_num != -1 && log_count + 1 > limit_num as i32 {
                self.print(&InternalLog::LogLimitExceeded { log_limit: self.log_limit.clone() }.translate(&self.lang), &mut Vec::new());
                break;
            }

            self.print(each_log, log_lines);
            log_count += 1;
        }
    }

    fn print(&self, log: &ConsoleLog, log_lines: &mut Vec<String>) {
        let kind_color = log.kind.get_log_color_num();
        let kind_name = &log.kind.get_log_kind_name();
        let msg = &log.msg;

        println!("{}", Console::format_title(Some(kind_color), kind_name, msg));
        log_lines.push(Console::format_title(None, kind_name, msg));

        println!();
        log_lines.push(String::new());
    }

    fn format_log_file_writing_failure_log() -> String {
        let err_log_kind = ConsoleLogKind::Error;
        return Console::format_title(Some(err_log_kind.get_log_color_num()), &err_log_kind.get_log_kind_name(), "log file writing failure");
    }

    fn format_title(color: Option<usize>, kind: &str, title: &str) -> String {
        let (color_begin, color_end) = match color {
            Some(v) => (format!("\x1b[{}m", v), "\x1b[m".to_string()),
            None => (String::new(), String::new()),
        };

        return format!("{}[{}]{} {}", color_begin, kind, color_end, title);
    }
}
